// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accommodation_room.sql

package database

import (
	"context"
	"strings"
)

const batchCountAccommodationRoomAvailable = `-- name: BatchCountAccommodationRoomAvailable :many
SELECT
    ar.accommodation_type AS accommodation_type_id,
    COUNT(ar.id) - COALESCE(booked_rooms.booked_count, 0) AS available_count
FROM
    ecommerce_go_accommodation_room ar
LEFT JOIN (
    SELECT
        ar_inner.accommodation_type,
        COUNT(orb.accommodation_room_id) AS booked_count
    FROM
        ecommerce_go_order ego
        JOIN ecommerce_go_order_detail egod ON ego.id = egod.order_id
        JOIN ecommerce_go_order_room_booking orb ON orb.order_detail_id = egod.id
        JOIN ecommerce_go_accommodation_room ar_inner ON ar_inner.id = orb.accommodation_room_id
    WHERE
        ? > ego.checkin_date
        AND ? < ego.checkout_date
        AND ego.order_status IN ('payment_success', 'checked_in')
        AND orb.booking_status IN ('reserved', 'checked_in')
    GROUP BY ar_inner.accommodation_type
) booked_rooms ON ar.accommodation_type = booked_rooms.accommodation_type
WHERE
    ar.accommodation_type IN (/*SLICE:ids*/?)
    AND ar.status = 'available'
    AND ar.is_deleted = 0
GROUP BY ar.accommodation_type
HAVING available_count > 0
`

type BatchCountAccommodationRoomAvailableParams struct {
	CheckOut uint64
	CheckIn  uint64
	Ids      []string
}

type BatchCountAccommodationRoomAvailableRow struct {
	AccommodationTypeID string
	AvailableCount      int32
}

func (q *Queries) BatchCountAccommodationRoomAvailable(ctx context.Context, arg BatchCountAccommodationRoomAvailableParams) ([]BatchCountAccommodationRoomAvailableRow, error) {
	query := batchCountAccommodationRoomAvailable
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CheckOut)
	queryParams = append(queryParams, arg.CheckIn)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchCountAccommodationRoomAvailableRow
	for rows.Next() {
		var i BatchCountAccommodationRoomAvailableRow
		if err := rows.Scan(&i.AccommodationTypeID, &i.AvailableCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const batchCountAccommodationRoomAvailableByManager = `-- name: BatchCountAccommodationRoomAvailableByManager :many
SELECT
    ar.accommodation_type as accommodation_type_id,
    COUNT(ar.id) as available_count
FROM
    ` + "`" + `ecommerce_go_accommodation_room` + "`" + ` ar
WHERE
    ar.accommodation_type IN (/*SLICE:accommodation_type_ids*/?)
    AND ar.status IN ('available') 
    AND ar.is_deleted = 0
GROUP BY ar.accommodation_type
`

type BatchCountAccommodationRoomAvailableByManagerRow struct {
	AccommodationTypeID string
	AvailableCount      int64
}

func (q *Queries) BatchCountAccommodationRoomAvailableByManager(ctx context.Context, accommodationTypeIds []string) ([]BatchCountAccommodationRoomAvailableByManagerRow, error) {
	query := batchCountAccommodationRoomAvailableByManager
	var queryParams []interface{}
	if len(accommodationTypeIds) > 0 {
		for _, v := range accommodationTypeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:accommodation_type_ids*/?", strings.Repeat(",?", len(accommodationTypeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:accommodation_type_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BatchCountAccommodationRoomAvailableByManagerRow
	for rows.Next() {
		var i BatchCountAccommodationRoomAvailableByManagerRow
		if err := rows.Scan(&i.AccommodationTypeID, &i.AvailableCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkAccommodationRoomBelongsToManager = `-- name: CheckAccommodationRoomBelongsToManager :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            ` + "`" + `ecommerce_go_accommodation` + "`" + ` ega
            JOIN ` + "`" + `ecommerce_go_accommodation_detail` + "`" + ` egad ON ega.id = egad.accommodation_id
            JOIN ` + "`" + `ecommerce_go_user_manager` + "`" + ` egum ON egum.id = ega.manager_id
            JOIN ` + "`" + `ecommerce_go_accommodation_room` + "`" + ` egar ON egar.accommodation_type = egad.id
        WHERE
            egum.id = ?
            AND egar.id = ?
            AND egar.is_deleted = 0
    )
`

type CheckAccommodationRoomBelongsToManagerParams struct {
	ManagerID           string
	AccommodationRoomID string
}

func (q *Queries) CheckAccommodationRoomBelongsToManager(ctx context.Context, arg CheckAccommodationRoomBelongsToManagerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAccommodationRoomBelongsToManager, arg.ManagerID, arg.AccommodationRoomID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkAccommodationTypeBelongToManager = `-- name: CheckAccommodationTypeBelongToManager :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            ` + "`" + `ecommerce_go_accommodation` + "`" + ` ega
            JOIN ` + "`" + `ecommerce_go_accommodation_detail` + "`" + ` egad ON ega.id = egad.accommodation_id
            JOIN ` + "`" + `ecommerce_go_user_manager` + "`" + ` egum ON egum.id = ega.manager_id
        WHERE
            egum.id = ?
            AND egad.id = ?
    )
`

type CheckAccommodationTypeBelongToManagerParams struct {
	ManagerID           string
	AccommodationTypeID string
}

func (q *Queries) CheckAccommodationTypeBelongToManager(ctx context.Context, arg CheckAccommodationTypeBelongToManagerParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAccommodationTypeBelongToManager, arg.ManagerID, arg.AccommodationTypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAccommodationRoom = `-- name: CreateAccommodationRoom :exec
INSERT INTO
    ` + "`" + `ecommerce_go_accommodation_room` + "`" + ` (
        ` + "`" + `id` + "`" + `,
        ` + "`" + `accommodation_type` + "`" + `,
        ` + "`" + `name` + "`" + `,
        ` + "`" + `status` + "`" + `,
        ` + "`" + `is_deleted` + "`" + `,
        ` + "`" + `created_at` + "`" + `,
        ` + "`" + `updated_at` + "`" + `
    )
VALUES
    (?, ?, ?, ?, 0, ?, ?)
`

type CreateAccommodationRoomParams struct {
	ID                string
	AccommodationType string
	Name              string
	Status            EcommerceGoAccommodationRoomStatus
	CreatedAt         uint64
	UpdatedAt         uint64
}

func (q *Queries) CreateAccommodationRoom(ctx context.Context, arg CreateAccommodationRoomParams) error {
	_, err := q.db.ExecContext(ctx, createAccommodationRoom,
		arg.ID,
		arg.AccommodationType,
		arg.Name,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteAccommodationRoom = `-- name: DeleteAccommodationRoom :exec
UPDATE ` + "`" + `ecommerce_go_accommodation_room` + "`" + `
SET
    ` + "`" + `is_deleted` + "`" + ` = 1
WHERE
    ` + "`" + `id` + "`" + ` = ?
`

func (q *Queries) DeleteAccommodationRoom(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAccommodationRoom, id)
	return err
}

const getAccommodationRoomAvailable = `-- name: GetAccommodationRoomAvailable :one
SELECT
    id, accommodation_type, name, status, is_deleted, created_at, updated_at
FROM
    ` + "`" + `ecommerce_go_accommodation_room` + "`" + ` ar
WHERE
    ar.id NOT IN (
        SELECT
            orb.accommodation_room_id
        FROM
            ` + "`" + `ecommerce_go_order` + "`" + ` ego
            JOIN ` + "`" + `ecommerce_go_order_detail` + "`" + ` egod ON ego.id = egod.order_id
            JOIN ` + "`" + `ecommerce_go_order_room_booking` + "`" + ` orb ON orb.order_detail_id = egod.id
        WHERE
            ? > ego.checkin_date
            AND ? < ego.checkout_date
            AND ego.order_status in ('payment_success', 'checked_in')
            AND orb.booking_status in ('reserved', 'checked_in')
    )
    AND ar.accommodation_type = ?
    AND ar.status in ('available')
    AND ar.is_deleted = 0
LIMIT
    1
`

type GetAccommodationRoomAvailableParams struct {
	CheckOut            uint64
	CheckIn             uint64
	AccommodationTypeID string
}

func (q *Queries) GetAccommodationRoomAvailable(ctx context.Context, arg GetAccommodationRoomAvailableParams) (EcommerceGoAccommodationRoom, error) {
	row := q.db.QueryRowContext(ctx, getAccommodationRoomAvailable, arg.CheckOut, arg.CheckIn, arg.AccommodationTypeID)
	var i EcommerceGoAccommodationRoom
	err := row.Scan(
		&i.ID,
		&i.AccommodationType,
		&i.Name,
		&i.Status,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccommodationRooms = `-- name: GetAccommodationRooms :many
SELECT
    ` + "`" + `id` + "`" + `,
    ` + "`" + `accommodation_type` + "`" + `,
    ` + "`" + `name` + "`" + `,
    ` + "`" + `status` + "`" + `
FROM
    ` + "`" + `ecommerce_go_accommodation_room` + "`" + `
WHERE
    ` + "`" + `accommodation_type` + "`" + ` = ?
    AND ` + "`" + `is_deleted` + "`" + ` = 0
ORDER BY ` + "`" + `created_at` + "`" + ` ASC
`

type GetAccommodationRoomsRow struct {
	ID                string
	AccommodationType string
	Name              string
	Status            EcommerceGoAccommodationRoomStatus
}

func (q *Queries) GetAccommodationRooms(ctx context.Context, accommodationtypeid string) ([]GetAccommodationRoomsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccommodationRooms, accommodationtypeid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAccommodationRoomsRow
	for rows.Next() {
		var i GetAccommodationRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.AccommodationType,
			&i.Name,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccommodationRoomsAvailableByQuantity = `-- name: GetAccommodationRoomsAvailableByQuantity :many
SELECT
    id, accommodation_type, name, status, is_deleted, created_at, updated_at
FROM
    ` + "`" + `ecommerce_go_accommodation_room` + "`" + ` ar
WHERE
    ar.id NOT IN (
        SELECT
            orb.accommodation_room_id
        FROM
            ` + "`" + `ecommerce_go_order` + "`" + ` ego
            JOIN ` + "`" + `ecommerce_go_order_detail` + "`" + ` egod ON ego.id = egod.order_id
            JOIN ` + "`" + `ecommerce_go_order_room_booking` + "`" + ` orb ON orb.order_detail_id = egod.id
        WHERE
            ? > ego.checkin_date
            AND ? < ego.checkout_date
            AND ego.order_status in ('payment_success', 'checked_in')
            AND orb.booking_status in ('reserved', 'checked_in')
    )
    AND ar.accommodation_type = ?
    AND ar.status in ('available')
    AND ar.is_deleted = 0
LIMIT
    ?
`

type GetAccommodationRoomsAvailableByQuantityParams struct {
	CheckOut            uint64
	CheckIn             uint64
	AccommodationTypeID string
	Limit               int32
}

func (q *Queries) GetAccommodationRoomsAvailableByQuantity(ctx context.Context, arg GetAccommodationRoomsAvailableByQuantityParams) ([]EcommerceGoAccommodationRoom, error) {
	rows, err := q.db.QueryContext(ctx, getAccommodationRoomsAvailableByQuantity,
		arg.CheckOut,
		arg.CheckIn,
		arg.AccommodationTypeID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EcommerceGoAccommodationRoom
	for rows.Next() {
		var i EcommerceGoAccommodationRoom
		if err := rows.Scan(
			&i.ID,
			&i.AccommodationType,
			&i.Name,
			&i.Status,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccommodationRooms = `-- name: UpdateAccommodationRooms :exec
UPDATE ` + "`" + `ecommerce_go_accommodation_room` + "`" + `
SET
    ` + "`" + `name` + "`" + ` = ?,
    ` + "`" + `status` + "`" + ` = ?,
    ` + "`" + `updated_at` + "`" + ` = ?
WHERE
    ` + "`" + `id` + "`" + ` = ?
    AND ` + "`" + `is_deleted` + "`" + ` = 0
`

type UpdateAccommodationRoomsParams struct {
	Name      string
	Status    EcommerceGoAccommodationRoomStatus
	UpdatedAt uint64
	ID        string
}

func (q *Queries) UpdateAccommodationRooms(ctx context.Context, arg UpdateAccommodationRoomsParams) error {
	_, err := q.db.ExecContext(ctx, updateAccommodationRooms,
		arg.Name,
		arg.Status,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
