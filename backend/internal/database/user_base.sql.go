// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_base.sql

package database

import (
	"context"
)

const addUserBase = `-- name: AddUserBase :exec
INSERT INTO
    ` + "`" + `ecommerce_go_user_base` + "`" + ` (
        ` + "`" + `id` + "`" + `,
        ` + "`" + `account` + "`" + `,
        ` + "`" + `password` + "`" + `,
        ` + "`" + `login_time` + "`" + `,
        ` + "`" + `login_ip` + "`" + `,
        ` + "`" + `logout_time` + "`" + `,
        ` + "`" + `is_verified` + "`" + `,
        ` + "`" + `created_at` + "`" + `,
        ` + "`" + `updated_at` + "`" + `
    )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AddUserBaseParams struct {
	ID         string
	Account    string
	Password   string
	LoginTime  uint64
	LoginIp    string
	LogoutTime uint64
	IsVerified uint8
	CreatedAt  uint64
	UpdatedAt  uint64
}

func (q *Queries) AddUserBase(ctx context.Context, arg AddUserBaseParams) error {
	_, err := q.db.ExecContext(ctx, addUserBase,
		arg.ID,
		arg.Account,
		arg.Password,
		arg.LoginTime,
		arg.LoginIp,
		arg.LogoutTime,
		arg.IsVerified,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const checkUserBaseExists = `-- name: CheckUserBaseExists :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            ` + "`" + `ecommerce_go_user_base` + "`" + `
        WHERE
            ` + "`" + `account` + "`" + ` = ?
            AND ` + "`" + `is_deleted` + "`" + ` = 0
    )
`

func (q *Queries) CheckUserBaseExists(ctx context.Context, account string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserBaseExists, account)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserBaseExistsById = `-- name: CheckUserBaseExistsById :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            ` + "`" + `ecommerce_go_user_base` + "`" + `
        WHERE
            ` + "`" + `id` + "`" + ` = ?
            AND ` + "`" + `is_deleted` + "`" + ` = 0
    )
`

func (q *Queries) CheckUserBaseExistsById(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserBaseExistsById, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getUserBaseByAccount = `-- name: GetUserBaseByAccount :one
SELECT
    ` + "`" + `id` + "`" + `,
    ` + "`" + `account` + "`" + `,
    ` + "`" + `password` + "`" + `
FROM
    ` + "`" + `ecommerce_go_user_base` + "`" + `
WHERE
    ` + "`" + `account` + "`" + ` = ?
LIMIT
    1
`

type GetUserBaseByAccountRow struct {
	ID       string
	Account  string
	Password string
}

func (q *Queries) GetUserBaseByAccount(ctx context.Context, account string) (GetUserBaseByAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBaseByAccount, account)
	var i GetUserBaseByAccountRow
	err := row.Scan(&i.ID, &i.Account, &i.Password)
	return i, err
}

const getUserBaseByIdAndReturnAccount = `-- name: GetUserBaseByIdAndReturnAccount :one
SELECT
    ` + "`" + `account` + "`" + `
FROM
    ` + "`" + `ecommerce_go_user_base` + "`" + `
WHERE
    ` + "`" + `id` + "`" + ` = ?
    AND ` + "`" + `is_deleted` + "`" + ` = 0
`

func (q *Queries) GetUserBaseByIdAndReturnAccount(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserBaseByIdAndReturnAccount, id)
	var account string
	err := row.Scan(&account)
	return account, err
}

const loginUserBase = `-- name: LoginUserBase :exec
UPDATE ` + "`" + `ecommerce_go_user_base` + "`" + `
SET
    ` + "`" + `login_time` + "`" + ` = ?,
    ` + "`" + `login_ip` + "`" + ` = ?
WHERE
    ` + "`" + `account` + "`" + ` = ?
`

type LoginUserBaseParams struct {
	LoginTime uint64
	LoginIp   string
	Account   string
}

func (q *Queries) LoginUserBase(ctx context.Context, arg LoginUserBaseParams) error {
	_, err := q.db.ExecContext(ctx, loginUserBase, arg.LoginTime, arg.LoginIp, arg.Account)
	return err
}

const logoutUserBase = `-- name: LogoutUserBase :exec
UPDATE ` + "`" + `ecommerce_go_user_base` + "`" + `
SET
    ` + "`" + `logout_time` + "`" + ` = ?
WHERE
    ` + "`" + `account` + "`" + ` = ?
`

type LogoutUserBaseParams struct {
	LogoutTime uint64
	Account    string
}

func (q *Queries) LogoutUserBase(ctx context.Context, arg LogoutUserBaseParams) error {
	_, err := q.db.ExecContext(ctx, logoutUserBase, arg.LogoutTime, arg.Account)
	return err
}
